"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.TriggerInvalidation = exports.Trigger = exports.InvocationType = void 0;
const jsiiDeprecationWarnings = require("../../.warnings.jsii.js");
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const path_1 = require("path");
const constructs_1 = require("constructs");
const core_1 = require("../../core");
/**
 * The invocation type to apply to a trigger. This determines whether the trigger function should await the result of the to be triggered function or not.
 */
var InvocationType;
(function (InvocationType) {
    /**
     * Invoke the function synchronously. Keep the connection open until the function returns a response or times out.
     * The API response includes the function response and additional data.
     */
    InvocationType["EVENT"] = "Event";
    /**
     * Invoke the function asynchronously. Send events that fail multiple times to the function's dead-letter queue (if one is configured).
     * The API response only includes a status code.
     */
    InvocationType["REQUEST_RESPONSE"] = "RequestResponse";
    /**
     *  Validate parameter values and verify that the user or role has permission to invoke the function.
     */
    InvocationType["DRY_RUN"] = "DryRun";
})(InvocationType = exports.InvocationType || (exports.InvocationType = {}));
/**
 * Triggers an AWS Lambda function during deployment.
 */
class Trigger extends constructs_1.Construct {
    constructor(scope, id, props) {
        super(scope, id);
        try {
            jsiiDeprecationWarnings.aws_cdk_lib_triggers_TriggerProps(props);
        }
        catch (error) {
            if (process.env.JSII_DEBUG !== "1" && error.name === "DeprecationError") {
                Error.captureStackTrace(error, Trigger);
            }
            throw error;
        }
        const handlerArn = this.determineHandlerArn(props);
        const provider = core_1.CustomResourceProvider.getOrCreateProvider(this, 'AWSCDK.TriggerCustomResourceProvider', {
            runtime: (0, core_1.builtInCustomResourceProviderNodeRuntime)(this),
            codeDirectory: (0, path_1.join)(__dirname, 'lambda'),
        });
        provider.addToRolePolicy({
            Effect: 'Allow',
            Action: ['lambda:InvokeFunction'],
            Resource: [`${props.handler.functionArn}:*`],
        });
        new core_1.CustomResource(this, 'Default', {
            resourceType: 'Custom::Trigger',
            serviceToken: provider.serviceToken,
            properties: {
                HandlerArn: handlerArn,
                InvocationType: props.invocationType ?? 'RequestResponse',
                Timeout: props.timeout?.toMilliseconds().toString() ?? core_1.Duration.minutes(2).toMilliseconds().toString(),
            },
        });
        this.executeAfter(...props.executeAfter ?? []);
        this.executeBefore(...props.executeBefore ?? []);
    }
    executeAfter(...scopes) {
        constructs_1.Node.of(this).addDependency(...scopes);
    }
    executeBefore(...scopes) {
        for (const s of scopes) {
            constructs_1.Node.of(s).addDependency(this);
        }
    }
    determineHandlerArn(props) {
        return props.handler.currentVersion.functionArn;
    }
}
_a = JSII_RTTI_SYMBOL_1;
Trigger[_a] = { fqn: "aws-cdk-lib.triggers.Trigger", version: "2.77.0" };
exports.Trigger = Trigger;
/**
 * Determines
 */
var TriggerInvalidation;
(function (TriggerInvalidation) {
    /**
     * The trigger will be executed every time the handler (or its configuration)
     * changes. This is implemented by associated the trigger with the `currentVersion`
     * of the AWS Lambda function, which gets recreated every time the handler changes.
     */
    TriggerInvalidation["HANDLER_CHANGE"] = "WHEN_FUNCTION_CHANGES";
})(TriggerInvalidation = exports.TriggerInvalidation || (exports.TriggerInvalidation = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJpZ2dlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInRyaWdnZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsK0JBQTRCO0FBQzVCLDJDQUF5RDtBQUV6RCxxQ0FBd0g7QUE0RHhIOztHQUVHO0FBQ0gsSUFBWSxjQWlCWDtBQWpCRCxXQUFZLGNBQWM7SUFDeEI7OztPQUdHO0lBQ0gsaUNBQWUsQ0FBQTtJQUVmOzs7T0FHRztJQUNILHNEQUFvQyxDQUFBO0lBRXBDOztPQUVHO0lBQ0gsb0NBQWtCLENBQUE7QUFDcEIsQ0FBQyxFQWpCVyxjQUFjLEdBQWQsc0JBQWMsS0FBZCxzQkFBYyxRQWlCekI7QUEwQkQ7O0dBRUc7QUFDSCxNQUFhLE9BQVEsU0FBUSxzQkFBUztJQUNwQyxZQUFZLEtBQWdCLEVBQUUsRUFBVSxFQUFFLEtBQW1CO1FBQzNELEtBQUssQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUM7Ozs7OzsrQ0FGUixPQUFPOzs7O1FBSWhCLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNuRCxNQUFNLFFBQVEsR0FBRyw2QkFBc0IsQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLEVBQUUsc0NBQXNDLEVBQUU7WUFDeEcsT0FBTyxFQUFFLElBQUEsK0NBQXdDLEVBQUMsSUFBSSxDQUFDO1lBQ3ZELGFBQWEsRUFBRSxJQUFBLFdBQUksRUFBQyxTQUFTLEVBQUUsUUFBUSxDQUFDO1NBQ3pDLENBQUMsQ0FBQztRQUVILFFBQVEsQ0FBQyxlQUFlLENBQUM7WUFDdkIsTUFBTSxFQUFFLE9BQU87WUFDZixNQUFNLEVBQUUsQ0FBQyx1QkFBdUIsQ0FBQztZQUNqQyxRQUFRLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsV0FBVyxJQUFJLENBQUM7U0FDN0MsQ0FBQyxDQUFDO1FBRUgsSUFBSSxxQkFBYyxDQUFDLElBQUksRUFBRSxTQUFTLEVBQUU7WUFDbEMsWUFBWSxFQUFFLGlCQUFpQjtZQUMvQixZQUFZLEVBQUUsUUFBUSxDQUFDLFlBQVk7WUFDbkMsVUFBVSxFQUFFO2dCQUNWLFVBQVUsRUFBRSxVQUFVO2dCQUN0QixjQUFjLEVBQUUsS0FBSyxDQUFDLGNBQWMsSUFBSSxpQkFBaUI7Z0JBQ3pELE9BQU8sRUFBRSxLQUFLLENBQUMsT0FBTyxFQUFFLGNBQWMsRUFBRSxDQUFDLFFBQVEsRUFBRSxJQUFJLGVBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsY0FBYyxFQUFFLENBQUMsUUFBUSxFQUFFO2FBQ3ZHO1NBQ0YsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLEtBQUssQ0FBQyxZQUFZLElBQUksRUFBRSxDQUFDLENBQUM7UUFDL0MsSUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLEtBQUssQ0FBQyxhQUFhLElBQUksRUFBRSxDQUFDLENBQUM7S0FDbEQ7SUFFTSxZQUFZLENBQUMsR0FBRyxNQUFtQjtRQUN4QyxpQkFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxhQUFhLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQztLQUN4QztJQUVNLGFBQWEsQ0FBQyxHQUFHLE1BQW1CO1FBQ3pDLEtBQUssTUFBTSxDQUFDLElBQUksTUFBTSxFQUFFO1lBQ3RCLGlCQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUNoQztLQUNGO0lBRU8sbUJBQW1CLENBQUMsS0FBbUI7UUFDN0MsT0FBTyxLQUFLLENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBQyxXQUFXLENBQUM7S0FNakQ7Ozs7QUEvQ1UsMEJBQU87QUFrRHBCOztHQUVHO0FBQ0gsSUFBWSxtQkFPWDtBQVBELFdBQVksbUJBQW1CO0lBQzdCOzs7O09BSUc7SUFDSCwrREFBd0MsQ0FBQTtBQUMxQyxDQUFDLEVBUFcsbUJBQW1CLEdBQW5CLDJCQUFtQixLQUFuQiwyQkFBbUIsUUFPOUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBqb2luIH0gZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBDb25zdHJ1Y3QsIElDb25zdHJ1Y3QsIE5vZGUgfSBmcm9tICdjb25zdHJ1Y3RzJztcbmltcG9ydCAqIGFzIGxhbWJkYSBmcm9tICcuLi8uLi9hd3MtbGFtYmRhJztcbmltcG9ydCB7IGJ1aWx0SW5DdXN0b21SZXNvdXJjZVByb3ZpZGVyTm9kZVJ1bnRpbWUsIEN1c3RvbVJlc291cmNlLCBDdXN0b21SZXNvdXJjZVByb3ZpZGVyLCBEdXJhdGlvbiB9IGZyb20gJy4uLy4uL2NvcmUnO1xuXG4vKipcbiAqIEludGVyZmFjZSBmb3IgdHJpZ2dlcnMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSVRyaWdnZXIgZXh0ZW5kcyBJQ29uc3RydWN0IHtcbiAgLyoqXG4gICAqIEFkZHMgdHJpZ2dlciBkZXBlbmRlbmNpZXMuIEV4ZWN1dGUgdGhpcyB0cmlnZ2VyIG9ubHkgYWZ0ZXIgdGhlc2UgY29uc3RydWN0XG4gICAqIHNjb3BlcyBoYXZlIGJlZW4gcHJvdmlzaW9uZWQuXG4gICAqXG4gICAqIEBwYXJhbSBzY29wZXMgQSBsaXN0IG9mIGNvbnN0cnVjdCBzY29wZXMgd2hpY2ggdGhpcyB0cmlnZ2VyIHdpbGwgZGVwZW5kIG9uLlxuICAgKi9cbiAgZXhlY3V0ZUFmdGVyKC4uLnNjb3BlczogQ29uc3RydWN0W10pOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBBZGRzIHRoaXMgdHJpZ2dlciBhcyBhIGRlcGVuZGVuY3kgb24gb3RoZXIgY29uc3RydWN0cy4gVGhpcyBtZWFucyB0aGF0IHRoaXNcbiAgICogdHJpZ2dlciB3aWxsIGdldCBleGVjdXRlZCAqYmVmb3JlKiB0aGUgZ2l2ZW4gY29uc3RydWN0KHMpLlxuICAgKlxuICAgKiBAcGFyYW0gc2NvcGVzIEEgbGlzdCBvZiBjb25zdHJ1Y3Qgc2NvcGVzIHdoaWNoIHdpbGwgdGFrZSBhIGRlcGVuZGVuY3kgb25cbiAgICogdGhpcyB0cmlnZ2VyLlxuICAgKi9cbiAgZXhlY3V0ZUJlZm9yZSguLi5zY29wZXM6IENvbnN0cnVjdFtdKTogdm9pZDtcbn1cblxuLyoqXG4gKiBPcHRpb25zIGZvciBgVHJpZ2dlcmAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVHJpZ2dlck9wdGlvbnMge1xuICAvKipcbiAgICogQWRkcyB0cmlnZ2VyIGRlcGVuZGVuY2llcy4gRXhlY3V0ZSB0aGlzIHRyaWdnZXIgb25seSBhZnRlciB0aGVzZSBjb25zdHJ1Y3RcbiAgICogc2NvcGVzIGhhdmUgYmVlbiBwcm92aXNpb25lZC5cbiAgICpcbiAgICogWW91IGNhbiBhbHNvIHVzZSBgdHJpZ2dlci5leGVjdXRlQWZ0ZXIoKWAgdG8gYWRkIGFkZGl0aW9uYWwgZGVwZW5kZW5jaWVzLlxuICAgKlxuICAgKiBAZGVmYXVsdCBbXVxuICAgKi9cbiAgcmVhZG9ubHkgZXhlY3V0ZUFmdGVyPzogQ29uc3RydWN0W107XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhpcyB0cmlnZ2VyIGFzIGEgZGVwZW5kZW5jeSBvbiBvdGhlciBjb25zdHJ1Y3RzLiBUaGlzIG1lYW5zIHRoYXQgdGhpc1xuICAgKiB0cmlnZ2VyIHdpbGwgZ2V0IGV4ZWN1dGVkICpiZWZvcmUqIHRoZSBnaXZlbiBjb25zdHJ1Y3QocykuXG4gICAqXG4gICAqIFlvdSBjYW4gYWxzbyB1c2UgYHRyaWdnZXIuZXhlY3V0ZUJlZm9yZSgpYCB0byBhZGQgYWRkaXRpb25hbCBkZXBlbmRhbnRzLlxuICAgKlxuICAgKiBAZGVmYXVsdCBbXVxuICAgKi9cbiAgcmVhZG9ubHkgZXhlY3V0ZUJlZm9yZT86IENvbnN0cnVjdFtdO1xuXG4gIC8qKlxuICAgKiBSZS1leGVjdXRlcyB0aGUgdHJpZ2dlciBldmVyeSB0aW1lIHRoZSBoYW5kbGVyIGNoYW5nZXMuXG4gICAqXG4gICAqIFRoaXMgaW1wbGllcyB0aGF0IHRoZSB0cmlnZ2VyIGlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgYGN1cnJlbnRWZXJzaW9uYCBvZlxuICAgKiB0aGUgaGFuZGxlciwgd2hpY2ggZ2V0cyByZWNyZWF0ZWQgZXZlcnkgdGltZSB0aGUgaGFuZGxlciBvciBpdHNcbiAgICogY29uZmlndXJhdGlvbiBpcyB1cGRhdGVkLlxuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICByZWFkb25seSBleGVjdXRlT25IYW5kbGVyQ2hhbmdlPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBUaGUgaW52b2NhdGlvbiB0eXBlIHRvIGFwcGx5IHRvIGEgdHJpZ2dlci4gVGhpcyBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHRyaWdnZXIgZnVuY3Rpb24gc2hvdWxkIGF3YWl0IHRoZSByZXN1bHQgb2YgdGhlIHRvIGJlIHRyaWdnZXJlZCBmdW5jdGlvbiBvciBub3QuXG4gKi9cbmV4cG9ydCBlbnVtIEludm9jYXRpb25UeXBlIHtcbiAgLyoqXG4gICAqIEludm9rZSB0aGUgZnVuY3Rpb24gc3luY2hyb25vdXNseS4gS2VlcCB0aGUgY29ubmVjdGlvbiBvcGVuIHVudGlsIHRoZSBmdW5jdGlvbiByZXR1cm5zIGEgcmVzcG9uc2Ugb3IgdGltZXMgb3V0LlxuICAgKiBUaGUgQVBJIHJlc3BvbnNlIGluY2x1ZGVzIHRoZSBmdW5jdGlvbiByZXNwb25zZSBhbmQgYWRkaXRpb25hbCBkYXRhLlxuICAgKi9cbiAgRVZFTlQgPSAnRXZlbnQnLFxuXG4gIC8qKlxuICAgKiBJbnZva2UgdGhlIGZ1bmN0aW9uIGFzeW5jaHJvbm91c2x5LiBTZW5kIGV2ZW50cyB0aGF0IGZhaWwgbXVsdGlwbGUgdGltZXMgdG8gdGhlIGZ1bmN0aW9uJ3MgZGVhZC1sZXR0ZXIgcXVldWUgKGlmIG9uZSBpcyBjb25maWd1cmVkKS5cbiAgICogVGhlIEFQSSByZXNwb25zZSBvbmx5IGluY2x1ZGVzIGEgc3RhdHVzIGNvZGUuXG4gICAqL1xuICBSRVFVRVNUX1JFU1BPTlNFID0gJ1JlcXVlc3RSZXNwb25zZScsXG5cbiAgLyoqXG4gICAqICBWYWxpZGF0ZSBwYXJhbWV0ZXIgdmFsdWVzIGFuZCB2ZXJpZnkgdGhhdCB0aGUgdXNlciBvciByb2xlIGhhcyBwZXJtaXNzaW9uIHRvIGludm9rZSB0aGUgZnVuY3Rpb24uXG4gICAqL1xuICBEUllfUlVOID0gJ0RyeVJ1bidcbn1cblxuLyoqXG4gKiBQcm9wcyBmb3IgYFRyaWdnZXJgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRyaWdnZXJQcm9wcyBleHRlbmRzIFRyaWdnZXJPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBBV1MgTGFtYmRhIGZ1bmN0aW9uIG9mIHRoZSBoYW5kbGVyIHRvIGV4ZWN1dGUuXG4gICAqL1xuICByZWFkb25seSBoYW5kbGVyOiBsYW1iZGEuRnVuY3Rpb247XG5cbiAgLyoqXG4gICAqIFRoZSBpbnZvY2F0aW9uIHR5cGUgdG8gaW52b2tlIHRoZSBMYW1iZGEgZnVuY3Rpb24gd2l0aC5cbiAgICpcbiAgICogQGRlZmF1bHQgUmVxdWVzdFJlc3BvbnNlXG4gICAqL1xuICByZWFkb25seSBpbnZvY2F0aW9uVHlwZT86IEludm9jYXRpb25UeXBlO1xuXG4gIC8qKlxuICAgKiBUaGUgdGltZW91dCBvZiB0aGUgaW52b2NhdGlvbiBjYWxsIG9mIHRoZSBMYW1iZGEgZnVuY3Rpb24gdG8gYmUgdHJpZ2dlcmVkLlxuICAgKlxuICAgKiBAZGVmYXVsdCBEdXJhdGlvbi5taW51dGVzKDIpXG4gICAqL1xuICByZWFkb25seSB0aW1lb3V0PzogRHVyYXRpb247XG59XG5cbi8qKlxuICogVHJpZ2dlcnMgYW4gQVdTIExhbWJkYSBmdW5jdGlvbiBkdXJpbmcgZGVwbG95bWVudC5cbiAqL1xuZXhwb3J0IGNsYXNzIFRyaWdnZXIgZXh0ZW5kcyBDb25zdHJ1Y3QgaW1wbGVtZW50cyBJVHJpZ2dlciB7XG4gIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBUcmlnZ2VyUHJvcHMpIHtcbiAgICBzdXBlcihzY29wZSwgaWQpO1xuXG4gICAgY29uc3QgaGFuZGxlckFybiA9IHRoaXMuZGV0ZXJtaW5lSGFuZGxlckFybihwcm9wcyk7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBDdXN0b21SZXNvdXJjZVByb3ZpZGVyLmdldE9yQ3JlYXRlUHJvdmlkZXIodGhpcywgJ0FXU0NESy5UcmlnZ2VyQ3VzdG9tUmVzb3VyY2VQcm92aWRlcicsIHtcbiAgICAgIHJ1bnRpbWU6IGJ1aWx0SW5DdXN0b21SZXNvdXJjZVByb3ZpZGVyTm9kZVJ1bnRpbWUodGhpcyksXG4gICAgICBjb2RlRGlyZWN0b3J5OiBqb2luKF9fZGlybmFtZSwgJ2xhbWJkYScpLFxuICAgIH0pO1xuXG4gICAgcHJvdmlkZXIuYWRkVG9Sb2xlUG9saWN5KHtcbiAgICAgIEVmZmVjdDogJ0FsbG93JyxcbiAgICAgIEFjdGlvbjogWydsYW1iZGE6SW52b2tlRnVuY3Rpb24nXSxcbiAgICAgIFJlc291cmNlOiBbYCR7cHJvcHMuaGFuZGxlci5mdW5jdGlvbkFybn06KmBdLFxuICAgIH0pO1xuXG4gICAgbmV3IEN1c3RvbVJlc291cmNlKHRoaXMsICdEZWZhdWx0Jywge1xuICAgICAgcmVzb3VyY2VUeXBlOiAnQ3VzdG9tOjpUcmlnZ2VyJyxcbiAgICAgIHNlcnZpY2VUb2tlbjogcHJvdmlkZXIuc2VydmljZVRva2VuLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBIYW5kbGVyQXJuOiBoYW5kbGVyQXJuLFxuICAgICAgICBJbnZvY2F0aW9uVHlwZTogcHJvcHMuaW52b2NhdGlvblR5cGUgPz8gJ1JlcXVlc3RSZXNwb25zZScsXG4gICAgICAgIFRpbWVvdXQ6IHByb3BzLnRpbWVvdXQ/LnRvTWlsbGlzZWNvbmRzKCkudG9TdHJpbmcoKSA/PyBEdXJhdGlvbi5taW51dGVzKDIpLnRvTWlsbGlzZWNvbmRzKCkudG9TdHJpbmcoKSxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB0aGlzLmV4ZWN1dGVBZnRlciguLi5wcm9wcy5leGVjdXRlQWZ0ZXIgPz8gW10pO1xuICAgIHRoaXMuZXhlY3V0ZUJlZm9yZSguLi5wcm9wcy5leGVjdXRlQmVmb3JlID8/IFtdKTtcbiAgfVxuXG4gIHB1YmxpYyBleGVjdXRlQWZ0ZXIoLi4uc2NvcGVzOiBDb25zdHJ1Y3RbXSk6IHZvaWQge1xuICAgIE5vZGUub2YodGhpcykuYWRkRGVwZW5kZW5jeSguLi5zY29wZXMpO1xuICB9XG5cbiAgcHVibGljIGV4ZWN1dGVCZWZvcmUoLi4uc2NvcGVzOiBDb25zdHJ1Y3RbXSk6IHZvaWQge1xuICAgIGZvciAoY29uc3QgcyBvZiBzY29wZXMpIHtcbiAgICAgIE5vZGUub2YocykuYWRkRGVwZW5kZW5jeSh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGRldGVybWluZUhhbmRsZXJBcm4ocHJvcHM6IFRyaWdnZXJQcm9wcykge1xuICAgIHJldHVybiBwcm9wcy5oYW5kbGVyLmN1cnJlbnRWZXJzaW9uLmZ1bmN0aW9uQXJuO1xuICAgIC8vIGNvbnN0IGV4ZWN1dGVPbkhhbmRsZXJDaGFuZ2UgPSBwcm9wcy5leGVjdXRlT25IYW5kbGVyQ2hhbmdlID8/IHRydWU7XG4gICAgLy8gaWYgKGV4ZWN1dGVPbkhhbmRsZXJDaGFuZ2UpIHtcbiAgICAvLyB9XG5cbiAgICAvLyByZXR1cm4gcHJvcHMuaGFuZGxlci5mdW5jdGlvbkFybjtcbiAgfVxufVxuXG4vKipcbiAqIERldGVybWluZXNcbiAqL1xuZXhwb3J0IGVudW0gVHJpZ2dlckludmFsaWRhdGlvbiB7XG4gIC8qKlxuICAgKiBUaGUgdHJpZ2dlciB3aWxsIGJlIGV4ZWN1dGVkIGV2ZXJ5IHRpbWUgdGhlIGhhbmRsZXIgKG9yIGl0cyBjb25maWd1cmF0aW9uKVxuICAgKiBjaGFuZ2VzLiBUaGlzIGlzIGltcGxlbWVudGVkIGJ5IGFzc29jaWF0ZWQgdGhlIHRyaWdnZXIgd2l0aCB0aGUgYGN1cnJlbnRWZXJzaW9uYFxuICAgKiBvZiB0aGUgQVdTIExhbWJkYSBmdW5jdGlvbiwgd2hpY2ggZ2V0cyByZWNyZWF0ZWQgZXZlcnkgdGltZSB0aGUgaGFuZGxlciBjaGFuZ2VzLlxuICAgKi9cbiAgSEFORExFUl9DSEFOR0UgPSAnV0hFTl9GVU5DVElPTl9DSEFOR0VTJyxcbn1cbiJdfQ==